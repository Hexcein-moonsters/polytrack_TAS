<script src="/lib/ammo.wasm.js"></script>
<script src="simulation_communicator.js"></script>
<script src="full_simulation_bundle.js"></script>
<script src="customInputs.js"></script>

<script src="/lib/kdTree.js"></script>
<script src="path.js"></script>
<script src="ai_environment.js"></script>

<h3 id="time">Loading...</h3>
<p id="replay"></p>



<br><br>
<hr>


<canvas id="view" style="width:100%;height:100%;border:1px solid #333"></canvas>

<script>
    (() => {
        let worldSize = 500; // will be modified automatically
        const worldSizePadding = 10; // when worldSize is set it will add +50 as empty space


        // ========= Canvas Setup =========
        const canvas = document.getElementById("view");
        const ctx = canvas.getContext("2d");

        // grid image setup to copy it when draw()'ing when the view doesn't change
        const gridCanvas = document.createElement("canvas");
        gridCanvas.width = canvas.width;
        gridCanvas.height = canvas.height;
        const gridCtx = gridCanvas.getContext("2d");


        let colorsUsed = [];
        let colorMap = new Map();
        
        let pins = [];


        // ========= Pan/Zoom State =========
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouse = { x: 0, y: 0 };

        // ========= Point Data =========
        let pointData = [];
        let yMin = 0, yMax = 1; // recalculated when event fires


        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;

            updateScreenPositions(); // <-- recompute only when view changes
            drawGridOnce(); // only when view changes
            draw();
        }
        window.addEventListener("resize", resize);
        resize();

        // ========= Event Listeners =========
        canvas.addEventListener("wheel", e => {
            const scaleAmount = 1.05;
            const mx = (e.offsetX - offsetX) / zoom;
            const my = (e.offsetY - offsetY) / zoom;

            const oldZoom = zoom;
            zoom *= e.deltaY < 0 ? scaleAmount : 1 / scaleAmount;

            offsetX = e.offsetX - mx * zoom;
            offsetY = e.offsetY - my * zoom;

            updateScreenPositions(); // <-- recompute only when view changes
            drawGridOnce(); // only when view changes
            draw();
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("mousedown", e => {
            if (e.button === 0) { // left click
                isPanning = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener("mouseup", () => isPanning = false);
        canvas.addEventListener("mouseleave", () => isPanning = false);

        canvas.addEventListener("mousemove", e => {
            if (isPanning) {
                offsetX += (e.clientX - lastMouse.x);
                offsetY += (e.clientY - lastMouse.y);
                lastMouse = { x: e.clientX, y: e.clientY };

                updateScreenPositions(); // <-- recompute only when view changes
                drawGridOnce(); // only when view changes
                draw();
            } else {
                draw(); // to show hover info
            }
        });

        // ========= Color Scale (Topo Map Style) =========
        function topoColor(t) { // returns a continuous rgb value
            // t ∈ [0,1]
            // A classic elevation map palette
            /*const stops = [
                [0.00, [30, 60, 140]], // deep blue
                [0.25, [80, 150, 200]], // light blue
                [0.40, [120, 180, 60]], // green
                [0.60, [200, 200, 60]], // yellow
                [0.75, [180, 120, 40]], // brown
                [1.00, [255, 255, 255]]  // white
            ];*/
            /*const stops = [
                [0.00, [30, 60, 140]],   // deep blue
                [0.25, [80, 150, 200]],  // light blue
                [0.40, [120, 180, 60]],  // green
                [0.60, [200, 200, 60]],  // yellow
                [0.75, [180, 120, 40]],  // brown
                [0.85, [210, 150, 80]],  // light brown
                [0.95, [240, 200, 140]], // sand/light yellow
                //[1.00, [255, 220, 180]]  // very light cream (not pure white)
                [1.00, [240, 50, 50]] // red
            ];*/
            const stops = [
                [0.00, [35, 50, 130]], // dark blue
                [0.25, [70, 170, 185]], // light blue
                [0.40, [80, 130, 50]], // green
                [0.60, [240, 225, 60]], // yellow
                [0.75, [255, 125, 0]], // orange
                [1.00, [200, 0, 0]] // red
            ];
            for (let i = 0; i < stops.length - 1; i++) {
                const [t1, c1] = stops[i];
                const [t2, c2] = stops[i + 1];

                if (t >= t1 && t <= t2) {
                    // It computes how far t is between these two stops
                    const k = (t - t1) / (t2 - t1); // k will be between 0 and 1

                    // Rounding instead of very long floats
                    const r = Math.round(c1[0] + (c2[0] - c1[0]) * k); // smoothly blends color 1 → color 2
                    const g = Math.round(c1[1] + (c2[1] - c1[1]) * k);
                    const b = Math.round(c1[2] + (c2[2] - c1[2]) * k);

                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            //return "white";
            return "rgb(255,220,180)"; // fallback to 'very light cream'
        }

        // ========= Coordinate Transform =========
        function worldToScreen(x, y) {
            return {
                x: x * zoom + offsetX,
                y: y * zoom + offsetY
            };
        }

        // ========= Drawing =========
        function drawGrid(ctx) {
            const step = 10; // world units. 10 meters of x/z = 1 grid box
            // if worldSize is 500 then: -500 to 500, both x and z (y here)
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(180,180,180,0.3)";
            ctx.beginPath();

            // step used to be 10, and the 500's used to all be 2000
            // canvas.height and canvas.width

            // Precompute screen bounds for world edges
            const topY = worldToScreen(0, -worldSize).y;
            const bottomY = worldToScreen(0, worldSize).y;
            const leftX = worldToScreen(-worldSize, 0).x;
            const rightX = worldToScreen(worldSize, 0).x;

            // Vertical lines
            for (let x = -worldSize; x <= worldSize; x += step) {
                const screenX = worldToScreen(x, 0).x; // Only one call per vertical line
                ctx.moveTo(screenX, topY);
                ctx.lineTo(screenX, bottomY);
            }

            // Horizontal lines
            for (let y = -worldSize; y <= worldSize; y += step) {
                const screenY = worldToScreen(0, y).y; // Only one call per horizontal line
                ctx.moveTo(leftX, screenY);
                ctx.lineTo(rightX, screenY);
            }

            ctx.stroke();
        }
        function drawGridOnce() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            drawGrid(gridCtx);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "black"; // setting background to black
            ctx.drawImage(gridCanvas, 0, 0);
            //drawGrid();

            // Draw points & lines
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.beginPath();
            for (let i = 0; i < pointData.length; i++) {
                if (i > 0) {
                    const p0 = worldToScreen(pointData[i - 1].x, pointData[i - 1].z);
                    const p1 = worldToScreen(pointData[i].x, pointData[i].z);
                    ctx.moveTo(p0.x, p0.y);
                    ctx.lineTo(p1.x, p1.y);
                }
            }
            ctx.stroke();

            // Draw points using precomputed colors
            /*for (let p of pointData) {
                const s = worldToScreen(p.x, p.z);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }*/

            drawPointsBatch();

            drawHover();

            for (const pin of pins) {
                const s = worldToScreen(pin.x, pin.y);
                drawPin({
                    x: s.x,
                    y: s.y,
                    radius: pin.radius,
                    color: pin.color
                });
            }
        }

        function drawPointsBatch() {
            const visibleMargin = 10; // small margin to avoid popping at edges

            /*for (let p of pointData) {
                //const s = worldToScreen(p.x, p.z);
                const sx = p.sx;
                const sy = p.sy;

                // Skip points completely offscreen
                if (sx < -visibleMargin || sx > canvas.width + visibleMargin ||
                    sy < -visibleMargin || sy > canvas.height + visibleMargin) {
                    continue;
                }

                //if (!colorMap.has(p.color)) colorMap.set(p.color, []);
                //colorMap.get(p.color).push({ x: sx, y: sy });

                //let arr = colorMap.get(p.color);
                //if (!arr) colorMap.set(p.color, arr = []);
                //arr.push([sx, sy]); // Use array instead of object to reduce allocations

                //colorMap.get(p.color).push([sx, sy]);
            }*/

            // Draw each color batch as 2x2 rectangle (fast!)
            for (let [color, points] of colorMap) {
                ctx.fillStyle = color;
                /*ctx.beginPath();
                for (let s of points) {
                    ctx.rect(s.x, s.y, 2, 2); // 2x2 pixels
                }
                ctx.fill();*/

                for (let [x, y] of points) { // not an object, it's an array
                    ctx.fillRect(x, y, 2, 2); // directly draw the tiny point
                }
            }
        }
        function updateScreenPositions() {
            const zx = zoom;
            const ox = offsetX;
            const oy = offsetY;

            colorMap = new Map(); // reset
            for (const c of colorsUsed) colorMap.set(c, []);

            for (let p of pointData) {
                p.sx = p.x * zx + ox;
                p.sy = p.z * zx + oy;

                colorMap.get(p.color).push([p.sx, p.sy]);
            }


        }


        function drawHover() {
            const mx = event?.offsetX;
            const my = event?.offsetY;
            if (mx == null || !carTree) return;

            // Convert mouse screen coords back to world coords
            const worldX = (mx - offsetX) / zoom;
            const worldZ = (my - offsetY) / zoom;

            // For hover, we can ignore y (just use x,z)
            const queryPoint = { x: worldX, y: 0, z: worldZ };

            // nearest returns [[point, distanceSquared], ...]
            const nearestResult = carTree.nearest(queryPoint, 1);
            if (!nearestResult.length) return;

            const [nearest, distSquared] = nearestResult[0];

            const nearestIndex = pointData.indexOf(nearest);
            const nearestActualPoint = pointData[nearestIndex];

            // Optional: only show if distance < some threshold in screen pixels
            const s = worldToScreen(nearest.x, nearest.z);
            const dx = s.x - mx;
            const dy = s.y - my;
            const screenDist = Math.sqrt(dx * dx + dy * dy); // convert d² -> d
            const maxDistance = 50; // pixels
            if (screenDist > maxDistance) return; // don't show if too far

            // Draw the hover info
            ctx.fillStyle = "black";
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;
            let text = `x:${nearest.x.toFixed(2)}, y:${nearest.y.toFixed(2)}, z:${nearest.z.toFixed(2)}`;
            text += `\nSpeedKmh: ${nearestActualPoint.speedKmh.toFixed(1)}`;
            ctx.font = "13px sans-serif";

            /*const w = ctx.measureText(text).width + 8;
            const h = 18;

            ctx.strokeRect(s.x + 10, s.y - h, w, h);
            ctx.fillRect(s.x + 10, s.y - h, w, h);

            ctx.fillStyle = "white";
            ctx.fillText(text, s.x + 14, s.y - 5);*/

            const lines = text.split('\n');
            const lineHeight = 18; // same as your rectangle height for consistency
            const w = Math.max(...lines.map(line => ctx.measureText(line).width)) + 8;
            const h = lineHeight * lines.length;

            ctx.strokeRect(s.x + 10, s.y - h, w, h);
            ctx.fillRect(s.x + 10, s.y - h, w, h);

            ctx.fillStyle = "white";

            lines.forEach((line, index) => {
                ctx.fillText(line, s.x + 14, s.y - h + lineHeight * (index + 1) - 5);
            });
        }

        function drawPin(pin) {
            ctx.save();
            ctx.translate(pin.x, pin.y);

            const scaleFactor = pin.radius * 3;
            ctx.scale(scaleFactor, scaleFactor);

            const path = new Path2D();
            const steps = 100;

            // --- Droplet contour polar curve ---
            for (let i = 0; i <= steps; i++) {
                const t = Math.PI + i * (Math.PI / steps);
                const x = 0.6 * Math.sin(t) * Math.cos(t);
                const y = Math.sin(t);

                if (i === 0) path.moveTo(x, y);
                else path.lineTo(x, y);
            }

            // close curve
            path.lineTo(0, 0);
            path.closePath();

            // --- Holle ---
            const holeY = -0.7; // topo da gota
            const holeRadius = 0.13
            path.moveTo(0 + holeRadius, holeY);
            path.arc(0, holeY, holeRadius, 0, Math.PI * 2, true);


            ctx.fillStyle = pin.color;
            ctx.fill(path, 'evenodd'); // importante: 'evenodd' cria o furo

            ctx.strokeStyle = "black";
            ctx.lineWidth = 0.02;
            ctx.stroke(path);

            ctx.restore();
        }




        addSharedEventListener("carTestDone", (points, lastState) => {
            const newPoints = [];
            points.forEach((point, index) => {
                //if (Math.random() < 0.8) continue; // 80% chance of not getting added
                if (index % 10 == 0) {
                    newPoints.push(point);
                }
            });
            pointData = [...newPoints];

            carTree = new kdTree([...pointData], distance3D, ["x", "y", "z"]);

            // determine y range for colors
            yMin = Math.min(...points.map(p => p.y));
            yMax = Math.max(...points.map(p => p.y));

            const smallestX = Math.min(...points.map(p => p.x));
            const largestX = Math.max(...points.map(p => p.x));
            const smallestZ = Math.min(...points.map(p => p.z));
            const largestZ = Math.max(...points.map(p => p.z));

            const largestBound = Math.max(
                Math.abs(smallestX), // negative -> positive
                Math.abs(largestX),
                Math.abs(smallestZ), // negative -> positive
                Math.abs(largestZ)
            );
            worldSize = Math.ceil(largestBound) + worldSizePadding;


            // Precompute colors
            //let previousPoint = pointData[0];
            for (let p of pointData) {
                const t = ((p.y - yMin) / (yMax - yMin || 1)) * 0.98; // optional scaling
                //const color = topoColor(t);
                // Math.random() * 360
                // Calculating the distance travelled from p0 to p1, which is car speed!
                /*const dx = p.x - previousPoint.x;
                const dy = p.z - previousPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy); // convert d² -> d
                previousPoint = p;*/
                const hslColor = Math.round(p.speedKmh / 1); //distance; // supports up to 360 speed
                let color = `hsla(${hslColor}, 100%, 50%, 1)`; // 100% saturation, 50% brightness, 1 opacity
                if (p.speedKmh < 0) color = 'black';
                p.color = color;
                if (!colorsUsed.includes(color)) colorsUsed.push(color);
            }
            updateScreenPositions(); // define sx and sy

            // Map from color → array of screen positions
            colorMap = new Map(); // reset
            for (const c of colorsUsed) colorMap.set(c, []);

            for (const p of pointData) {
                const sx = p.sx;
                const sy = p.sy;

                colorMap.get(p.color).push([sx, sy]);
            }


            pins.push({
                x: lastState.position.x,
                y: lastState.position.z,
                radius: 5,
                color: 'rgb(255, 0, 0)'
            });


            drawGridOnce();
            draw();
        });

        let carTree;
    })();
</script>